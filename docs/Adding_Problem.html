<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Adding a Problem</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Propeller</span> <span class="project-version">0.3.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="A_Guide_To_Propeller.html"><div class="inner"><span>A Guide to Propeller</span></div></a></li><li class="depth-1 "><a href="Adding_Genetic_Operators.html"><div class="inner"><span>Adding Genetic Operators</span></div></a></li><li class="depth-1  current"><a href="Adding_Problem.html"><div class="inner"><span>Adding a Problem</span></div></a></li><li class="depth-1 "><a href="Adding_Selection_Method.html"><div class="inner"><span>Adding a Selection Method</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>propeller</span></div></div></li><li class="depth-2 branch"><a href="propeller.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>problems</span></div></div></li><li class="depth-3"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>software</span></div></div></li><li class="depth-4"><a href="propeller.problems.software.fizz-buzz.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fizz-buzz</span></div></a></li><li class="depth-2 branch"><a href="propeller.selection.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>selection</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tools</span></div></div></li><li class="depth-3 branch"><a href="propeller.tools.calculus.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>calculus</span></div></a></li><li class="depth-3 branch"><a href="propeller.tools.character.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>character</span></div></a></li><li class="depth-3 branch"><a href="propeller.tools.distributions.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>distributions</span></div></a></li><li class="depth-3 branch"><a href="propeller.tools.math.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>math</span></div></a></li><li class="depth-3"><a href="propeller.tools.metrics.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>metrics</span></div></a></li><li class="depth-2 branch"><a href="propeller.utils.html"><div class="inner"><span class="tree" style="top: -176px;"><span class="top" style="height: 185px;"></span><span class="bottom"></span></span><span>utils</span></div></a></li><li class="depth-2"><a href="propeller.variation.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>variation</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#adding-a-problem" id="adding-a-problem"></a>Adding a Problem</h1>
<p>In general, a problem file has 3 components: <code>train-and-test-data</code>, <code>instructions</code>, <code>error-function</code>, and <code>-main</code>.</p>
<ol>
<li>To add a new problem, you need training and test data. For Problem Synthesis Benchmark Problems (PSB2), you can fetch datasets using <code>psb2.core/fetch-examples</code>.</li>
</ol>
<pre><code class="language-clojure">(defn fetch-examples
  "Fetches and returns training and test data from a PSB2 problem.
   Returns a map of the form {:train training-examples :test testing-examples}
   where training-examples and testing-examples are lists of training and test
   data. The elements of these lists are maps of the form:
   {:input1 first-input :input2 second-input ... :output1 first-output ...}
   The training examples will include all hard-coded edge cases included in the suite,
   along with enough random cases to include `n-train` cases.
   Note that this function loads large datasets and can be slow, 30-120 seconds.
   Parameters:
     `datasets-directory` - Location of the PSB2 datasets as downloaded from https://zenodo.org/record/4678739
     `problem-name` - Name of the PSB2 problem, lowercase and seperated by dashes.
         - Ex: indices-of-substring
     `n-train` - Number of training cases to return
     `n-test` - Number of test cases to return"
  [datasets-directory problem-name n-train n-test]

</code></pre>
<ol>
<li>Define the possible Push instructions to be used to create plushys. It should be a non-lazy list of instructions from <code>push/instructions</code></li>
<li>Define an error function that will evaluate plushys and add <code>:behaviors parsed-outputs</code>, <code>:errors</code>, and <code>:total-error</code> to the individual</li>
<li>Define the function <code>-main</code> with a map of default arguments.</li>
</ol>
<h2><a href="#example-of-a-problem" id="example-of-a-problem"></a>Example of a Problem</h2>
<pre><code class="language-clojure">(ns propeller.problems.PSB2.solve-boolean
  (:require [psb2.core :as psb2]
            [propeller.genome :as genome]
            [propeller.push.interpreter :as interpreter]
            [propeller.utils :as utils]
            [propeller.push.instructions :refer [get-stack-instructions]]
            [propeller.push.state :as state]
            [propeller.gp :as gp]
            #?(:cljs [cljs.reader :refer [read-string]])))

; ===========  PROBLEM DESCRIPTION  ================================
; SOLVE BOOLEAN from PSB2
; Given a string representing a Boolean
; expression consisting of T, F, |, and &amp;, evaluate it and return
; the resulting Boolean.
;
; Source: https://arxiv.org/pdf/2106.06086.pdf
; ==================================================================

(def train-and-test-data (psb2/fetch-examples "data" "solve-boolean" 200 2000))

(def instructions
  (utils/not-lazy
    (concat
      ;;; stack-specific instructions
      (get-stack-instructions #{:exec :integer :boolean :char :string :print})
      ;;; input instructions
      (list :in1)
      ;;; close
      (list 'close)
      ;;; ERCs (constants)
      (list true false \t \f \&amp; \|))))

(defn error-function
  [argmap data individual]
  (let [program (genome/plushy-&gt;push (:plushy individual) argmap)
        inputs (map (fn [i] (get i :input1)) data)
        correct-outputs (map (fn [i] (get i :output1)) data)
        outputs (map (fn [input]
                       (state/peek-stack
                         (interpreter/interpret-program
                           program
                           (assoc state/empty-state :input {:in1 input})
                           (:step-limit argmap))
                         :boolean))
                     inputs)
        parsed-outputs (map (fn [output]
                              (try (read-string output)
                                   #?(:clj  (catch Exception e 1000.0)
                                      :cljs (catch js/Error. e 1000.0))))
                            outputs)
        errors (map (fn [correct-output output]
                      (if (= output :no-stack-item)
                        10000
                        (if (= correct-output output)
                           0
                           1)))
                    correct-outputs
                    parsed-outputs)]
    (assoc individual
      :behaviors parsed-outputs
      :errors errors
      :total-error #?(:clj  (apply +' errors)
                      :cljs (apply + errors)))))

(defn -main
  "Runs propel-gp, giving it a map of arguments."
  [&amp; args]
  (gp/gp
    (merge
      {:instructions            instructions
       :error-function          error-function
       :training-data           (:train train-and-test-data)
       :testing-data            (:test train-and-test-data)
       :max-generations         300
       :population-size         1000
       :max-initial-plushy-size 250
       :step-limit              2000
       :parent-selection        :lexicase
       :tournament-size         5
       :umad-rate               0.1
       :variation               {:umad 1.0 :crossover 0.0}
       :elitism                 false}
      (apply hash-map (map #(if (string? %) (read-string %) %) args))))
  (#?(:clj shutdown-agents)))

</code></pre>
</div></div></div></body></html>